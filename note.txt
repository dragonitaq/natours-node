What is the difference between using pagination in Front-end and Back-end?

The need of pagination on front-end/back-end have different purposes: Basically backend tends to improve performance and resource usage while front-end improves user experience/usability. The pagination on both not necessarily are mutually exclusive and its need should be evaluated per scenario.

Imagine a scenario for a "resource" which has a dataset of 100 elements with simple attributes each element.. It would be totally fine to not have pagination on backend and leave it up to the front end to present and do the pagination. But for example, an api for retrieve all books of a library with hundreds of thousands of book available... It can be bad for the backend/infrastructure/frontend to try to manage all this dataset at once.. 

As mentioned before they are not mutually exclusive and you make usage for both so for example.. we have a service with 200 elements available and the backend pagination of limit of 50 per request (total of 4 "pages").. but in your front end you want to present only 10 elements at a time, so your front end can get the 50 initial one, display 10 and keep some in memory.. so it would need to get more elements from page 6.. of course it add some more complexity and the frontend need to manage well this logic to know when it need to get resource or if is available to display any page. But it can happen. And even the other way around.. where the front end needs to present 100 at time, so it would need to make 2 requests to the backend for each "fronted page".

The pagination on the backend just specify how it will return the data (in chunks).. the frontend presentation should adequate and manage its usage to fulfil its need.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

req.body is the main body content (not header) we receive, normally in JSON format, but it can also be text. We normally use app.use(express.json()); to convert JSON into JS object.

req.query is the URL that start with ? follow by query parameters.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

Middleware allows you to call a function for each request that comes in. The alternative would be to call the function in a controller, but then you have to repeat it in every controller. Middleware lets you define it in a single place and have all the requests pass through it.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

req-res cycle ends immediately right after whenever we send something with res. Any code down the line to handle that req-res will not apply.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

this.query = this.query.find(JSON.parse(queryStr));
What does this line of code do actually?

Jonas' reply:

So, the APIFeatures class expects a mongoose query object as an input. The way we create a query object is by creating a query with Tour.find(), but not executing the query right away, so not using await on it (in case we're using async/await like we do in the course).

Again, by doing this, we end up with a query object onto which we can then chain other methods, such as sort, or another find, as you posted in your example:

this.query.find(JSON.parse(queryStr))

Keep in mind that here, inside the class, this.query is the query object we created in the beginning, so it's like having:

Tour.find().find(JSON.parse(queryStr))

And yes, that is totally acceptable. Again, because the query has not yet executed, it didn't return the actual results yet. That's what we do in the end, which is the reason why in the end we have to use

const tours = await features.query;

My own word:

Tour.find().find(JSON.parse(queryStr))

Tour.find() return a query object, and then we manipulate it. This query object is then execute another find() method with parameters of JSON.parse(queryStr) in which it will return another new query object too.
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

We can define functions on the schema. Refer here:
https://mongoosejs.com/docs/guide.html#methods
But cannot declare the function using ES6 => arrow function.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

Sub-documents are documents embedded in other documents. In Mongoose, this means you can nest schemas in other schemas. Mongoose has two distinct notions of sub-documents: arrays of sub-documents and single nested sub-documents.

const childSchema = new Schema({ name: 'string' });

const parentSchema = new Schema({
  // Array of sub-documents
  children: [childSchema],
  // Single nested sub-documents
  child: childSchema,
});

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

About client vs server side validator, we should have both. But the must-have validation is on the server. The client-side validation just provides a better user experience so they don't have to reload the page to know what they did wrong.