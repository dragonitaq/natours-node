What is the difference between using pagination in Front-end and Back-end?

The need of pagination on front-end/back-end have different purposes: Basically backend tends to improve performance and resource usage while front-end improves user experience/usability. The pagination on both not necessarily are mutually exclusive and its need should be evaluated per scenario.

Imagine a scenario for a "resource" which has a dataset of 100 elements with simple attributes each element.. It would be totally fine to not have pagination on backend and leave it up to the front end to present and do the pagination. But for example, an api for retrieve all books of a library with hundreds of thousands of book available... It can be bad for the backend/infrastructure/frontend to try to manage all this dataset at once.. 

As mentioned before they are not mutually exclusive and you make usage for both so for example.. we have a service with 200 elements available and the backend pagination of limit of 50 per request (total of 4 "pages").. but in your front end you want to present only 10 elements at a time, so your front end can get the 50 initial one, display 10 and keep some in memory.. so it would need to get more elements from page 6.. of course it add some more complexity and the frontend need to manage well this logic to know when it need to get resource or if is available to display any page. But it can happen. And even the other way around.. where the front end needs to present 100 at time, so it would need to make 2 requests to the backend for each "fronted page".

The pagination on the backend just specify how it will return the data (in chunks).. the frontend presentation should adequate and manage its usage to fulfil its need.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

req.body is the main body content (not header) we receive, normally in JSON format, but it can also be text. We normally use app.use(express.json()); to convert JSON into JS object.

req.query is the URL that start with ? follow by query parameters.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

Middleware allows you to call a function for each request that comes in. The alternative would be to call the function in a controller, but then you have to repeat it in every controller. Middleware lets you define it in a single place and have all the requests pass through it.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

req-res cycle ends immediately right after whenever we send something with res. Any code down the line to handle that req-res will not apply.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

this.query = this.query.find(JSON.parse(queryStr));
What does this line of code do actually?

Jonas' reply:

So, the APIFeatures class expects a mongoose query object as an input. The way we create a query object is by creating a query with Tour.find(), but not executing the query right away, so not using await on it (in case we're using async/await like we do in the course).

Again, by doing this, we end up with a query object onto which we can then chain other methods, such as sort, or another find, as you posted in your example:

this.query.find(JSON.parse(queryStr))

Keep in mind that here, inside the class, this.query is the query object we created in the beginning, so it's like having:

Tour.find().find(JSON.parse(queryStr))

And yes, that is totally acceptable. Again, because the query has not yet executed, it didn't return the actual results yet. That's what we do in the end, which is the reason why in the end we have to use

const tours = await features.query;

My own word:

Tour.find().find(JSON.parse(queryStr))

Tour.find() return a query object, and then we manipulate it. This query object is then execute another find() method with parameters of JSON.parse(queryStr) in which it will return another new query object too.
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

We can define functions on the schema. Refer here:
https://mongoosejs.com/docs/guide.html#methods
But cannot declare the function using ES6 => arrow function.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

Sub-documents are documents embedded in other documents. In Mongoose, this means you can nest schemas in other schemas. Mongoose has two distinct notions of sub-documents: arrays of sub-documents and single nested sub-documents.

const childSchema = new Schema({ name: 'string' });

const parentSchema = new Schema({
  // Array of sub-documents
  children: [childSchema],
  // Single nested sub-documents
  child: childSchema,
});

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

About client vs server side validator, we should have both. But the must-have validation is on the server. The client-side validation just provides a better user experience so they don't have to reload the page to know what they did wrong.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

Error stack / Error stack trace is information that shows us where the error happened.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

Difference between findByIdAndDelete VS findByIdAndRemove

We should use findByIdAndDelete and not findByIdAndRemove unless you have a good reason not to.
findOneAndRemove returns the removed document so if you remove a document that you later decide should not be removed, you can insert it back into the db.
This can be useful too. For example your user wants to delete his account but u need to delete user information too then u can use findOneAndRemove() and then u can delete it on users table and after that u can add to another table as "deletedUser".
If we want to response a delete successful message to the client, then we need to change the status code, because no matter what message you send, status code 204 will hide all of it.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

There are two possible errors regarding mongoose id validation.

1. Mongoose try to convert a random string in a valid objectId. If failed, then the ID is malformed so findById will reject it.
-> Cast to ObjectId failed for value

2. The ID is properly formatted, but it doesn't exist in the database.
-> findById() returns null.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

When handling errors in our async/await function, if use the keyword 'throw', it also yields the same result since catchAsync function already has a catch block. But this is not a good practice principle.

The reason we pass errors down to the global error handling middleware by passing an error to next() is because that's how Express designed to work. We should follow the pattern that Express created for us because that pattern is the philosophy of middleware.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

3 types of mongoose error:
1) Invalid id (cast to objectId error)
2) Duplicate key error (key value must be unique.)
3) Validation error (general data model schema validation error)

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

As for as I can tell, whenever Mongoose throws an error, it has its name property. Whereas, when Mongo throws an error, it has its code property.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

There are more things can do in error handling, we can define different error severity levels like not important, medium, very important and critical. Then we get warn or contact differently base on severity.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

We should not always rely on process.on('unhandledRejection') or process.on('uncaughtException') to handle our errors. We should always handle errors case by case basic. Only those errors that we can't think of or never expected, the only they go in there because that is our last safety net.

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

In real life scenario, you do not push buggy code to production. You develop on your local machine and push it to DEVELOPMENT environment. You test your newly added feature there as well. After that, QA tester will test your changes on STAGING environment. After QA tester confirms that everything is OK, then you will push to PRODUCTION environment.

In case some bugs are still on PRODUCTION. Then, you will have to revert the new deployment to previous version that does not have any bug.